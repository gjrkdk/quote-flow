---
phase: 12-admin-ui-option-groups
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/routes/app.option-groups.new.tsx
  - app/routes/app.option-groups.$id.edit.tsx
autonomous: true

must_haves:
  truths:
    - "Merchant can create a new option group with name, requirement type, and dynamic choices"
    - "Merchant can edit an existing option group's name, requirement type, and choices"
    - "Choices support label, modifier type (FIXED/PERCENTAGE), modifier value, and default flag"
    - "Form enforces caps: max 20 choices per group"
    - "Form validation errors are shown via Banner"
  artifacts:
    - path: "app/routes/app.option-groups.new.tsx"
      provides: "Create option group form with dynamic choices"
      exports: ["action", "default"]
    - path: "app/routes/app.option-groups.$id.edit.tsx"
      provides: "Edit option group form with pre-populated data"
      exports: ["loader", "action", "default"]
  key_links:
    - from: "app/routes/app.option-groups.new.tsx"
      to: "app/services/option-group.server.ts"
      via: "createOptionGroup service call"
      pattern: "createOptionGroup"
    - from: "app/routes/app.option-groups.$id.edit.tsx"
      to: "app/services/option-group.server.ts"
      via: "getOptionGroup and updateOptionGroup service calls"
      pattern: "getOptionGroup|updateOptionGroup"
    - from: "app/routes/app.option-groups.new.tsx"
      to: "app/validators/option-group.validators.ts"
      via: "OptionGroupCreateSchema validation"
      pattern: "OptionGroupCreateSchema"
    - from: "app/routes/app.option-groups.$id.edit.tsx"
      to: "app/validators/option-group.validators.ts"
      via: "OptionGroupUpdateSchema validation"
      pattern: "OptionGroupUpdateSchema"
---

<objective>
Create the option group create and edit forms with dynamic choice management, JSON serialization for nested data, and Zod validation integration.

Purpose: Merchants need forms to define option groups (e.g., "Glass Type", "Edge Finish") with choices that have price modifiers. The create and edit forms share the same dynamic choice pattern.
Output: Two fully functional form routes for creating and editing option groups with their choices.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/routes/app.matrices.new.tsx
@app/routes/app.matrices.$id.edit.tsx
@app/services/option-group.server.ts
@app/validators/option-group.validators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the new option group form with dynamic choices</name>
  <files>app/routes/app.option-groups.new.tsx</files>
  <action>
Create app/routes/app.option-groups.new.tsx following patterns from app/routes/app.matrices.new.tsx and the research code examples.

**Action function:**
- Authenticate with `authenticate.admin(request)`
- Extract `data` field from formData (JSON string)
- `JSON.parse(data)` then validate with `OptionGroupCreateSchema.parse(data)`
- Find store by `session.shop`
- Call `createOptionGroup(store.id, validated)` from service layer
- On success: `redirect(`/app/option-groups/${optionGroup.id}/edit`)`
- Catch errors: if ZodError, extract first issue message; otherwise use error.message
- Return `json({ error: message }, { status: 400 })` on failure

**Component (NewOptionGroup):**
- Use `useNavigate`, `useFetcher<typeof action>`
- Local state:
  - `name: string` (empty initially)
  - `requirement: "REQUIRED" | "OPTIONAL"` (default "OPTIONAL")
  - `choices: Choice[]` (initially one empty choice: `{ label: "", modifierType: "FIXED", modifierValue: 0, isDefault: false }`)
- Choice type: `{ label: string, modifierType: "FIXED" | "PERCENTAGE", modifierValue: number, isDefault: boolean }`

**Choice management functions (all with useCallback):**
- `addChoice`: Append new default choice to array. Disabled when choices.length >= 20.
- `removeChoice(index)`: Filter out by index. Only allowed when choices.length > 1.
- `updateChoice(index, field, value)`: Spread-copy array, update specific field.

**Form submission (handleSubmit):**
- Construct `{ name, requirement, choices }` object
- Serialize with `JSON.stringify`
- Submit via `fetcher.submit({ data: JSON.stringify(data) }, { method: "post" })`

**Layout (using Polaris components):**

Page component:
- title="Create option group"
- backAction navigates to "/app/option-groups"

Layout.Section 1 — Error banner:
- Show `Banner tone="critical"` when actionData has error field

Layout.Section 2 — Group details card:
- Card with BlockStack gap="400"
- TextField for "Group name": value={name}, onChange={setName}, autoComplete="off", maxLength={100}, placeholder="e.g., Material, Size, Finish", requiredIndicator, helpText="Choose a descriptive name for this option group"
- Select for "Requirement": options "Optional - customers can skip" (OPTIONAL) and "Required - customers must select" (REQUIRED), helpText changes based on selection

Layout.Section 3 — Choices card:
- Card with BlockStack gap="400"
- Header: InlineStack with "Choices" heading and "Add choice" Button (disabled at 20)
- Banner tone="warning" when choices.length >= 20: "Maximum 20 choices per group."
- BlockStack gap="300" containing choice cards:
  - Each choice in a nested Card with BlockStack gap="300":
    - Header: InlineStack with "Choice {index + 1}" text and "Remove" button (plain, critical, hidden when only 1 choice)
    - TextField "Label": value, onChange, autoComplete="off", maxLength=100, placeholder "e.g., Premium Glass, Standard Glass", requiredIndicator
    - Select "Modifier type": "Fixed amount (e.g., +$5.00)" = FIXED, "Percentage (e.g., +10%)" = PERCENTAGE
    - TextField "Modifier value": type="number", value as String, parseInt on change (|| 0 for NaN), helpText differs by type:
      - FIXED: "Enter amount in cents (500 = $5.00). Negative values allowed for discounts."
      - PERCENTAGE: "Enter percentage in basis points (1000 = 10%). Negative values allowed for discounts."
    - Checkbox "Set as default choice" (only shown when requirement === "OPTIONAL"): helpText "Optional groups can have one default choice pre-selected"

Layout.Section 4 — Action buttons:
- InlineStack gap="300" align="end"
- Button "Cancel" navigates to "/app/option-groups"
- Button "Create option group": variant="primary", onClick={handleSubmit}, loading when fetcher submitting, disabled when !name.trim() || choices.length === 0
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no new TypeScript errors in the new file. Navigate to /app/option-groups/new in browser and verify form renders with one empty choice.
  </verify>
  <done>Create form renders with group name, requirement select, dynamic choices with add/remove, modifier type/value fields, default checkbox for optional groups, and submits via JSON to create service.</done>
</task>

<task type="auto">
  <name>Task 2: Create the edit option group form with pre-populated data</name>
  <files>app/routes/app.option-groups.$id.edit.tsx</files>
  <action>
Create app/routes/app.option-groups.$id.edit.tsx following the create form pattern but with loader for pre-population and update logic.

**Loader function:**
- Authenticate with `authenticate.admin(request)`
- Extract `id` from params; throw 400 if missing
- Find store by `session.shop`; throw 404 if not found
- Call `getOptionGroup(id, store.id)` from service layer
- If null, throw 404 "Option group not found"
- Serialize response: `{ optionGroup: { id, name, requirement, choices: group.choices.map(c => ({ id: c.id, label: c.label, modifierType: c.modifierType, modifierValue: c.modifierValue, isDefault: c.isDefault })), productCount: group._count.products } }`

**Action function:**
- Authenticate, extract `id` from params
- Extract `data` field from formData (JSON string)
- Parse and validate with `OptionGroupUpdateSchema.parse(data)`
- Find store by `session.shop`
- Call `updateOptionGroup(id, store.id, validated)` from service layer
- If null, return error "Option group not found"
- On success: return `json({ success: true })`
- Catch errors same as create form

**Component (EditOptionGroup):**
- Use `useLoaderData<typeof loader>`, `useNavigate`, `useFetcher<typeof action>`
- Initialize state FROM loader data (not empty):
  - `name`: from loaderData.optionGroup.name
  - `requirement`: from loaderData.optionGroup.requirement
  - `choices`: from loaderData.optionGroup.choices (map to include existing choice IDs)
- Choice type extends create: add optional `id?: string` field

**Same choice management functions as create form** (addChoice, removeChoice, updateChoice).

**Form submission (handleSubmit):**
- Construct `{ name, requirement, choices }` — include choice id if present (for tracking)
- Serialize and submit via fetcher same as create form

**Layout differences from create form:**
- Page title={name} (dynamic, shows current group name)
- backAction navigates to "/app/option-groups"
- Success banner: show "Option group saved successfully" when action returns success
- Product count info: show "Used by N products" as Text tone="subdued" near the top of the page (informational)
- Submit button text: "Save" instead of "Create option group"
- No redirect on save — stay on edit page with success banner

**Important implementation details:**
- Pre-populate all fields from loader data using useState initial values
- The edit form stays on the same page after save (no redirect)
- Show success/error banners based on fetcher.data
- Product count shown as informational text, not editable
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no new TypeScript errors. After creating an option group via Plan 02 Task 1, navigate to /app/option-groups/{id}/edit and verify form is pre-populated with saved data. Save changes and verify success banner appears.
  </verify>
  <done>Edit form loads with pre-populated data from existing option group, allows editing all fields including dynamic choices, submits updates via JSON to update service, and shows success/error feedback.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without new errors in option-group form files
2. Navigate to /app/option-groups/new — form renders with name, requirement, and one empty choice
3. Add/remove choices works, cap at 20 enforced with warning banner
4. Submit create form — redirects to edit page for newly created group
5. Edit form pre-populates all fields from database
6. Save on edit form — success banner appears, data persisted
7. Validation errors (empty name, no choices) shown in error banner
8. Default checkbox only appears for OPTIONAL groups
</verification>

<success_criteria>
- Create form at /app/option-groups/new with all fields working
- Edit form at /app/option-groups/:id/edit with pre-populated data
- Dynamic choice add/remove with 20-choice cap enforcement
- JSON serialization for nested form data
- Zod validation with error feedback via Banner
- Modifier type/value with appropriate help text for FIXED vs PERCENTAGE
- Default choice checkbox only for OPTIONAL groups
</success_criteria>

<output>
After completion, create `.planning/phases/12-admin-ui-option-groups/12-02-SUMMARY.md`
</output>
