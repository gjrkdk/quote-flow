---
phase: 13-rest-api-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/validators/api.validators.ts
  - app/services/option-validator.server.ts
autonomous: true

must_haves:
  truths:
    - "Option selection schemas validate structure (optionGroupId + choiceId pairs)"
    - "Business rule validation rejects selections for groups not assigned to the product"
    - "Business rule validation rejects invalid choice IDs that don't belong to their groups"
    - "Business rule validation enforces at most one selection per option group"
    - "Business rule validation enforces required groups must have a selection"
    - "Validation returns descriptive error messages with group/choice names"
  artifacts:
    - path: "app/validators/api.validators.ts"
      provides: "OptionSelectionSchema, OptionSelectionsSchema, extended PriceQuerySchema and DraftOrderSchema"
      contains: "OptionSelectionSchema"
    - path: "app/services/option-validator.server.ts"
      provides: "validateOptionSelections service function"
      exports: ["validateOptionSelections"]
  key_links:
    - from: "app/services/option-validator.server.ts"
      to: "app/services/option-group.server.ts"
      via: "getProductOptionGroups function call"
      pattern: "getProductOptionGroups"
    - from: "app/validators/api.validators.ts"
      to: "zod"
      via: "schema definitions with .optional()"
      pattern: "z\\.object"
---

<objective>
Create validation schemas for option selections and a service-layer validator that enforces business rules (selections match product's assigned groups, valid choices, required groups selected).

Purpose: Foundation for both the price endpoint (Plan 02) and draft orders endpoint (Plan 02) to validate option selections before calculation.
Output: Extended Zod schemas in api.validators.ts and new option-validator.server.ts service.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rest-api-extension/13-RESEARCH.md
@app/validators/api.validators.ts
@app/services/option-group.server.ts
@app/services/option-price-calculator.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend API validators with option selection schemas</name>
  <files>app/validators/api.validators.ts</files>
  <action>
Extend the existing api.validators.ts file with option selection validation schemas. Add the following schemas after the existing DraftOrderSchema:

1. `OptionSelectionSchema` — validates a single selection object:
   - `optionGroupId`: z.string().min(1, "Option group ID is required")
   - `choiceId`: z.string().min(1, "Choice ID is required")

2. `OptionSelectionsSchema` — validates the JSON-encoded options parameter for GET requests:
   - An object with `selections` array of OptionSelectionSchema items
   - Max 5 selections (matches the 5 groups per product cap)

3. Extend `PriceQuerySchema` by creating `PriceQueryWithOptionsSchema`:
   - Spread all existing PriceQuerySchema fields (width, height, quantity)
   - Add `options`: z.string().optional() — JSON-encoded string for GET query params

4. Extend `DraftOrderSchema` by creating `DraftOrderWithOptionsSchema`:
   - Spread all existing DraftOrderSchema fields (productId, width, height, quantity)
   - Add `options`: z.array(OptionSelectionSchema).max(5).optional() — direct array for POST body

Export all new schemas and inferred TypeScript types (OptionSelection, OptionSelections).

Keep existing schemas unchanged for backward compatibility — do NOT modify PriceQuerySchema or DraftOrderSchema themselves.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm TypeScript compilation succeeds. Verify the file exports the new schemas by checking the file content.</verify>
  <done>Four new schemas exported (OptionSelectionSchema, OptionSelectionsSchema, PriceQueryWithOptionsSchema, DraftOrderWithOptionsSchema) alongside unchanged originals. TypeScript types inferred and exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create option validator service with business rule validation</name>
  <files>app/services/option-validator.server.ts</files>
  <action>
Create a new service file `app/services/option-validator.server.ts` that validates option selections against a product's assigned option groups. Follow the existing service pattern from option-group.server.ts.

Implement `validateOptionSelections` function:

```
Interface: validateOptionSelections(
  productId: string,    // GID format
  selections: Array<{optionGroupId: string, choiceId: string}>,
  storeId: string
) => Promise<ValidationResult>

Interface ValidationResult:
  valid: boolean
  error?: string
  validatedGroups?: Array (the fetched option groups for downstream use, avoids re-fetching)
```

Business rules to enforce (in this order):
1. Fetch product's option groups via `getProductOptionGroups(productId, storeId)` from option-group.server.ts
2. If null returned (product not found or unauthorized), return `{ valid: false, error: "Product not found or not authorized" }`
3. Check: all selected optionGroupIds must be in the product's assigned groups. Error: `Option group "{name}" is not assigned to this product` (use group name if found, ID if not)
4. Check: all selected choiceIds must belong to their respective option groups. Error: `Choice "${choiceId}" does not belong to option group "${groupName}"`
5. Check: at most one selection per option group. Error: `Multiple selections for option group "${groupName}" (only one allowed)`
6. Check: all REQUIRED groups must have a selection (OPTIONAL groups can be omitted). Error: `Required option group "${groupName}" must have a selection`

Return `validatedGroups` on success so the caller can pass the groups to the price calculator without re-fetching from database.

Use Maps and Sets for efficient lookups (build groupMap and choiceMap once).

Include JSDoc documentation with examples following the pattern in option-price-calculator.server.ts.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm TypeScript compilation succeeds. Verify the file exports validateOptionSelections.</verify>
  <done>option-validator.server.ts exports validateOptionSelections with all 4 business rules (group assignment, choice membership, one-per-group, required groups). Returns validated groups for downstream use. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (TypeScript compilation)
2. api.validators.ts has 4 new schema exports alongside unchanged originals
3. option-validator.server.ts exports validateOptionSelections function
4. validateOptionSelections imports getProductOptionGroups from option-group.server.ts
5. All validation error messages reference human-readable names (not just IDs)
</verification>

<success_criteria>
- Extended Zod schemas compile and export correctly
- Option validator service enforces all 4 business rules
- Existing PriceQuerySchema and DraftOrderSchema remain unchanged
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/13-rest-api-extension/13-01-SUMMARY.md`
</output>
