---
phase: 13-rest-api-extension
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - app/routes/api.v1.products.$productId.price.ts
  - app/routes/api.v1.draft-orders.ts
  - app/services/draft-order.server.ts
autonomous: true

must_haves:
  truths:
    - "REST API accepts option selections alongside dimensions and returns total price with breakdown"
    - "API validates that option selections match product's assigned option groups"
    - "Existing API calls without options return identical response format (backward compatible)"
    - "Price breakdown shows basePrice, optionModifiers array, and modified price when options provided"
    - "Draft Orders include selected options as line item custom attributes"
    - "Draft Order local record stores option selections as JSON"
    - "API returns descriptive errors for invalid option selections"
  artifacts:
    - path: "app/routes/api.v1.products.$productId.price.ts"
      provides: "Extended price endpoint with optional options parameter"
      contains: "optionModifiers"
    - path: "app/routes/api.v1.draft-orders.ts"
      provides: "Extended draft orders endpoint with optional options parameter"
      contains: "options"
    - path: "app/services/draft-order.server.ts"
      provides: "Extended submitDraftOrder accepting option metadata"
      contains: "customAttributes"
  key_links:
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/services/option-validator.server.ts"
      via: "validateOptionSelections call"
      pattern: "validateOptionSelections"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/services/option-price-calculator.server.ts"
      via: "calculatePriceWithOptions call"
      pattern: "calculatePriceWithOptions"
    - from: "app/routes/api.v1.draft-orders.ts"
      to: "app/services/option-validator.server.ts"
      via: "validateOptionSelections call"
      pattern: "validateOptionSelections"
    - from: "app/routes/api.v1.draft-orders.ts"
      to: "app/services/draft-order.server.ts"
      via: "submitDraftOrder with options metadata"
      pattern: "submitDraftOrder"
---

<objective>
Extend both REST API endpoints (price lookup and draft orders) to accept optional option selections, validate them, calculate modified prices, and return detailed breakdowns. Extend Draft Order service to include option metadata in Shopify custom attributes and local records.

Purpose: Complete the API extension for option group pricing, maintaining full backward compatibility for existing clients.
Output: Modified price endpoint, draft orders endpoint, and draft order service.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rest-api-extension/13-RESEARCH.md
@.planning/phases/13-rest-api-extension/13-01-SUMMARY.md
@app/routes/api.v1.products.$productId.price.ts
@app/routes/api.v1.draft-orders.ts
@app/services/draft-order.server.ts
@app/services/option-price-calculator.server.ts
@app/services/option-validator.server.ts
@app/validators/api.validators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend price endpoint to accept options and return breakdown</name>
  <files>app/routes/api.v1.products.$productId.price.ts</files>
  <action>
Extend the existing price endpoint loader to handle optional option selections. The key principle is: when no options are provided, the response MUST be identical to the current format (backward compatible). When options are provided, add basePrice and optionModifiers to the response.

Changes to the loader function:

1. **Import new dependencies:**
   - Import `PriceQueryWithOptionsSchema` and `OptionSelectionsSchema` from `~/validators/api.validators`
   - Import `validateOptionSelections` from `~/services/option-validator.server`
   - Import `calculatePriceWithOptions` and `PriceModifier` from `~/services/option-price-calculator.server`
   - Import `getProductOptionGroups` from `~/services/option-group.server` (needed if validator returns groups)

2. **Replace PriceQuerySchema with PriceQueryWithOptionsSchema** in the query parameter validation (step 4). Extract `options` from the validated data alongside width, height, quantity.

3. **After dimension validation (step 5), add option parsing and validation:**
   - Extract `options` from query params (already validated as optional string by Zod)
   - If `options` is present:
     a. Try JSON.parse(options). If fails, throw 400 "Invalid options JSON"
     b. Validate parsed JSON with OptionSelectionsSchema.safeParse(). If fails, throw 400 "Invalid options format" with field errors
     c. Extract `parsedSelections` from validation result's `.selections` array
     d. Call `validateOptionSelections(normalizedProductId, parsedSelections, store.id)`
     e. If validation fails, throw 400 with the validation error message
     f. Keep reference to `validatedGroups` from the result for price calculation

4. **Modify price calculation (step 7):**
   - If no options provided OR parsedSelections is empty: calculate as before (existing `calculatePrice`), return existing response format UNCHANGED
   - If options provided: build PriceModifier[] array from validatedGroups by matching each selection's choiceId to the group's choices. For each matched choice, create a PriceModifier with type, value, and label "{groupName}: {choiceLabel}". Call `calculatePriceWithOptions(basePriceCents, modifiers)` from option-price-calculator.server.ts. This returns `{ basePriceCents, modifiers: ModifierBreakdown[], totalCents }`.

5. **Modify response format for options case:**
   ```
   {
     basePrice: result.basePriceCents,
     optionModifiers: result.modifiers.map(m => ({
       optionGroup: [extract group name from label before colon],
       choice: [extract choice label from label after colon],
       modifierType: m.type,
       modifierValue: m.originalValue,
       appliedAmount: m.appliedAmountCents,
     })),
     price: result.totalCents,         // unit price after modifiers
     currency: productMatrix.currency,
     dimensions: { width, height, unit: productMatrix.unit },
     quantity,
     total: result.totalCents * quantity,
     matrix: productMatrix.matrixName,
     dimensionRange: productMatrix.dimensionRange,
   }
   ```

IMPORTANT: To build the PriceModifier[] for calculatePriceWithOptions, iterate over parsedSelections and look up the matching choice from validatedGroups. The label format should be "GroupName: ChoiceLabel" so it can be split in the response mapping, OR store groupName/choiceLabel separately in a local mapping used when building the response. The cleaner approach: build both a PriceModifier[] for calculation AND a parallel metadata array for response formatting.

IMPORTANT: For the no-options path, ensure the response is byte-identical to current behavior — same fields, same order, same types.

Handle errors from JSON parsing with try/catch that re-throws Response objects (same pattern as existing error handling).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compilation. Manually verify the file structure:
1. PriceQueryWithOptionsSchema used for query validation
2. Options parsing with JSON.parse + Zod validation
3. validateOptionSelections called when options present
4. calculatePriceWithOptions called for price with modifiers
5. Response includes basePrice + optionModifiers when options provided
6. Response unchanged when no options
  </verify>
  <done>Price endpoint accepts optional `options` query parameter as JSON string. When provided, validates selections against product's assigned groups, calculates price with modifiers, and returns breakdown with basePrice, optionModifiers[], and modified price/total. When omitted, returns identical response to Phase 4.</done>
</task>

<task type="auto">
  <name>Task 2: Extend draft orders endpoint and service with option support</name>
  <files>app/routes/api.v1.draft-orders.ts, app/services/draft-order.server.ts</files>
  <action>
Extend the draft orders endpoint and service to accept option selections, validate them, calculate modified prices, and include options in both Shopify custom attributes and local records.

**Part A: Extend draft-order.server.ts**

1. Add optional `options` field to `SubmitDraftOrderInput` interface:
   ```typescript
   options?: Array<{
     optionGroupName: string;
     choiceLabel: string;
   }>;
   ```

2. In `submitDraftOrder` function, after building the base customAttributes array (Width, Height):
   - If `input.options` is provided and has items, append each option as a custom attribute:
     ```typescript
     { key: option.optionGroupName, value: option.choiceLabel }
     ```

3. In the local DraftOrderRecord creation (`prisma.$transaction`), add `optionSelections` field:
   - First, add the field to the Prisma schema (see note below). BUT since we don't want to do a migration in this task (schema changes need migration), we can store this data by adding a JSON field. WAIT — check if DraftOrderRecord already has an optionSelections field... It does NOT.

   **Schema migration approach:** Add `optionSelections Json? @map("option_selections")` to the DraftOrderRecord model in prisma/schema.prisma. Run `npx prisma migrate dev --name add_option_selections_to_draft_orders` to create and apply the migration.

4. Update the local record creation to include: `optionSelections: input.options ? JSON.stringify(input.options) : null`
   Actually, since Prisma handles Json type natively, just pass the array directly: `optionSelections: input.options ?? null`

**Part B: Extend api.v1.draft-orders.ts**

1. **Import new dependencies:**
   - Import `DraftOrderWithOptionsSchema` from `~/validators/api.validators` (replace DraftOrderSchema usage)
   - Import `validateOptionSelections` from `~/services/option-validator.server`
   - Import `calculatePriceWithOptions`, `PriceModifier` from `~/services/option-price-calculator.server`

2. **Replace DraftOrderSchema with DraftOrderWithOptionsSchema** in body validation (step 3). Extract `options` from validated data alongside productId, width, height, quantity.

3. **After dimension validation (step 4), add option validation:**
   - If `options` is provided and has items:
     a. Call `validateOptionSelections(normalizedProductId, options, store.id)`
     b. If validation fails, throw 400 with validation error message
     c. Keep reference to `validatedGroups` from result

4. **Modify price calculation (step 6):**
   - If no options: calculate as before with `calculatePrice`, set `unitPrice = calculatedPrice`
   - If options provided: calculate base price first with `calculatePrice`, then build PriceModifier[] from validatedGroups + selections (same approach as price endpoint), call `calculatePriceWithOptions(basePriceCents, modifiers)`, set `unitPrice = result.totalCents`

5. **Build option metadata for Draft Order:**
   - If options provided, create options metadata array:
     ```typescript
     const optionMetadata = selections.map(s => {
       // Look up group name and choice label from validatedGroups
       return { optionGroupName: groupName, choiceLabel: choiceLabel };
     });
     ```

6. **Pass options to submitDraftOrder:**
   - Add `options: optionMetadata` to the submitDraftOrder call

7. **Extend response** to include price breakdown when options were used:
   - When options provided, add `basePrice` and `optionModifiers` to response (same format as price endpoint)
   - When no options, keep response unchanged for backward compatibility

**Part C: Prisma schema + migration**

Add to DraftOrderRecord model in prisma/schema.prisma:
```prisma
optionSelections    Json?       @map("option_selections")
```

Run migration: `npx prisma migrate dev --name add_option_selections_to_draft_orders`

IMPORTANT: The Prisma migration must be run before the code changes can be tested. Create migration first, then modify service and route files.

IMPORTANT: For backward compatibility, when no options are provided to the draft orders endpoint, the response MUST be identical to the current format.
  </action>
  <verify>
1. Run `npx prisma migrate dev --name add_option_selections_to_draft_orders` to verify migration creates and applies
2. Run `npx tsc --noEmit` to confirm TypeScript compilation
3. Verify draft-order.server.ts has options in SubmitDraftOrderInput interface
4. Verify draft-order.server.ts adds option custom attributes conditionally
5. Verify api.v1.draft-orders.ts uses DraftOrderWithOptionsSchema
6. Verify api.v1.draft-orders.ts calls validateOptionSelections when options present
7. Verify DraftOrderRecord has optionSelections Json? field
  </verify>
  <done>Draft orders endpoint accepts optional `options` array in POST body. When provided, validates selections, calculates modified price, includes option names/labels as Shopify Draft Order custom attributes alongside Width/Height, stores selections as JSON in local DraftOrderRecord, and returns price breakdown in response. When omitted, behavior identical to Phase 5.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx prisma migrate dev` succeeds with new migration
3. Price endpoint: GET without options returns same response as before
4. Price endpoint: GET with valid options returns basePrice + optionModifiers + modified price
5. Price endpoint: GET with invalid options returns 400 with descriptive error
6. Draft orders: POST without options creates Draft Order as before
7. Draft orders: POST with valid options creates Draft Order with option custom attributes
8. Draft orders: POST with invalid options returns 400 with descriptive error
9. DraftOrderRecord stores optionSelections JSON when options provided
</verification>

<success_criteria>
- Both endpoints accept option selections and return modified prices
- Both endpoints validate selections against product's assigned groups
- Draft Orders include option metadata as custom attributes
- Local records store option selections as JSON
- Backward compatibility maintained — existing clients work unchanged
- All prices calculated using integer cents arithmetic
</success_criteria>

<output>
After completion, create `.planning/phases/13-rest-api-extension/13-02-SUMMARY.md`
</output>
