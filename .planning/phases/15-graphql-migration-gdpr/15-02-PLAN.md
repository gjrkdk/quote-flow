---
phase: 15-graphql-migration-gdpr
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - app/routes/webhooks.tsx
  - app/routes/api.cron.process-jobs.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "GDPR webhooks enqueue async jobs instead of performing synchronous deletion"
    - "Webhook responses return within 200ms"
    - "Cron endpoint processes pending jobs from the queue"
    - "shop/redact webhook removes all option groups and matrices for the store (via async job)"
    - "CUSTOMERS_DATA_REQUEST webhook acknowledges without deletion"
  artifacts:
    - path: "app/routes/webhooks.tsx"
      provides: "Webhook handlers that enqueue async jobs"
      contains: "enqueueJob"
    - path: "app/routes/api.cron.process-jobs.ts"
      provides: "Vercel Cron endpoint for job queue processing"
      exports: ["loader"]
    - path: "vercel.json"
      provides: "Cron schedule configuration for job processing"
      contains: "crons"
  key_links:
    - from: "app/routes/webhooks.tsx"
      to: "app/services/job-queue.server.ts"
      via: "enqueueJob call for async processing"
      pattern: "enqueueJob"
    - from: "app/routes/api.cron.process-jobs.ts"
      to: "app/services/job-queue.server.ts"
      via: "processNextJob call in cron handler"
      pattern: "processNextJob"
    - from: "vercel.json"
      to: "app/routes/api.cron.process-jobs.ts"
      via: "Cron schedule triggers the endpoint"
      pattern: "api/cron/process-jobs"
---

<objective>
Refactor GDPR webhook handlers to use async job queue and add Vercel Cron endpoint for job processing.

Purpose: Webhook handlers must respond within 200ms (Shopify retries after 5s). The current synchronous deletion in SHOP_REDACT risks timeout on large stores. By enqueuing jobs and returning immediately, webhooks stay fast. A Vercel Cron endpoint processes the queue in the background.

Output: Refactored webhooks.tsx, new cron API route, vercel.json with cron config.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-graphql-migration-gdpr/15-RESEARCH.md
@.planning/phases/15-graphql-migration-gdpr/15-01-SUMMARY.md
@app/routes/webhooks.tsx
@app/services/job-queue.server.ts
@app/services/gdpr-deletion.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor webhook handlers to enqueue async jobs</name>
  <files>app/routes/webhooks.tsx</files>
  <action>
Refactor `app/routes/webhooks.tsx` to use the job queue instead of synchronous processing.

Import enqueueJob from "~/services/job-queue.server".

Replace the current switch statement logic:

**CUSTOMERS_DATA_REQUEST:** Keep as acknowledgment-only (no change needed). Add comment: "App does not store customer-specific data. Acknowledge receipt per Shopify requirements."

**CUSTOMERS_REDACT:** Replace the synchronous `prisma.gdprRequest.updateMany()` with:
```typescript
await enqueueJob("customer_redact", { shop });
```
Remove the direct prisma call. The job handler in gdpr-deletion.server.ts will mark the GDPR request as processed.

**SHOP_REDACT:** Replace the synchronous `prisma.store.deleteMany()` and `prisma.gdprRequest.updateMany()` with:
```typescript
await enqueueJob("shop_redact", { shop });
```
Remove both direct prisma calls. The job handler will perform the cascade delete and mark GDPR requests as processed.

**APP_UNINSTALLED:** Keep as-is (no data deletion, keep for reinstall).

The GDPR request logging at the top of the action (the `prisma.gdprRequest.create()` call) should remain â€” this logs the incoming webhook payload for audit trail BEFORE enqueueing the async job.

Add a `const startTime = Date.now()` at the start of the action and a `console.log(\`[Webhook] ${topic} processed in ${Date.now() - startTime}ms\`)` before the return statement to track response time.

The webhook handler should still return `new Response(null, { status: 200 })` at the end.
  </action>
  <verify>
Read webhooks.tsx and verify: (1) enqueueJob is imported, (2) SHOP_REDACT calls enqueueJob instead of prisma.store.deleteMany, (3) CUSTOMERS_REDACT calls enqueueJob instead of prisma.gdprRequest.updateMany, (4) GDPR request audit logging is preserved, (5) response timing is logged. TypeScript compiles: `npx tsc --noEmit --skipLibCheck 2>&1 | grep webhooks || echo "No errors"`.
  </verify>
  <done>webhooks.tsx enqueues async jobs for CUSTOMERS_REDACT and SHOP_REDACT instead of synchronous deletion. GDPR request audit trail preserved. Response timing logged.</done>
</task>

<task type="auto">
  <name>Task 2: Create Vercel Cron endpoint and configuration for job processing</name>
  <files>app/routes/api.cron.process-jobs.ts, vercel.json</files>
  <action>
**Part A: Create the cron API route**

Create `app/routes/api.cron.process-jobs.ts` as a Remix resource route (no default export).

Export a `loader` function (GET handler) that:

1. Verify the request is from Vercel Cron by checking the `Authorization` header:
```typescript
const authHeader = request.headers.get("authorization");
if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
  return new Response("Unauthorized", { status: 401 });
}
```
This uses the CRON_SECRET env var that Vercel automatically provides to cron jobs.

2. Process up to 10 jobs in a loop:
```typescript
let processed = 0;
let errors = 0;
const maxJobs = 10;

for (let i = 0; i < maxJobs; i++) {
  const result = await processNextJob();
  if (!result.processed) break; // No more pending jobs
  processed++;
  if (result.error) errors++;
}
```

3. Return JSON response with processing summary:
```typescript
return new Response(
  JSON.stringify({
    processed,
    errors,
    timestamp: new Date().toISOString(),
  }),
  {
    status: 200,
    headers: { "Content-Type": "application/json" },
  }
);
```

4. Add console.log: `[Cron] Processed ${processed} jobs (${errors} errors)`

Import processNextJob from "~/services/job-queue.server".
Import type LoaderFunctionArgs from "@remix-run/node".

**Part B: Create vercel.json**

Create `vercel.json` in the project root with cron configuration:
```json
{
  "crons": [
    {
      "path": "/api/cron/process-jobs",
      "schedule": "* * * * *"
    }
  ]
}
```

This runs the job processor every minute. With up to 10 jobs per invocation, this handles up to 600 jobs/hour which is more than sufficient for GDPR webhook volume.

Note: Vercel Cron on the Hobby plan runs at minimum every minute. The Pro plan supports sub-minute intervals. Every-minute is sufficient for GDPR processing (Shopify retries over 4 hours).
  </action>
  <verify>
1. File exists at app/routes/api.cron.process-jobs.ts with loader export
2. File exists at vercel.json with crons array
3. TypeScript compiles: `npx tsc --noEmit --skipLibCheck 2>&1 | grep "api.cron" || echo "No errors"`
4. vercel.json is valid JSON: `node -e "JSON.parse(require('fs').readFileSync('vercel.json', 'utf8')); console.log('Valid JSON')"`
  </verify>
  <done>Cron endpoint at /api/cron/process-jobs processes up to 10 pending jobs per invocation. Secured with CRON_SECRET authorization. vercel.json configures every-minute cron schedule.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --skipLibCheck` passes for all modified files
2. webhooks.tsx imports and uses enqueueJob for CUSTOMERS_REDACT and SHOP_REDACT
3. webhooks.tsx preserves GDPR request audit logging (prisma.gdprRequest.create)
4. api.cron.process-jobs.ts exports loader with auth check and batch processing
5. vercel.json exists with valid cron configuration
6. Full chain: webhook -> enqueueJob -> JobQueue table -> cron -> processNextJob -> GDPR deletion
</verification>

<success_criteria>
- GDPR webhooks enqueue jobs instead of synchronous deletion
- Webhook response time is logged and expected to be under 200ms
- Cron endpoint processes pending jobs with authorization
- vercel.json configures every-minute cron schedule
- End-to-end async flow: webhook enqueue -> cron process -> GDPR deletion
</success_criteria>

<output>
After completion, create `.planning/phases/15-graphql-migration-gdpr/15-02-SUMMARY.md`
</output>
