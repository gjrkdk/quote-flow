---
phase: 15-graphql-migration-gdpr
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - app/services/job-queue.server.ts
  - app/services/gdpr-deletion.server.ts
autonomous: true

must_haves:
  truths:
    - "Jobs can be enqueued with type and payload and stored in database"
    - "Jobs are processed atomically (no duplicate processing)"
    - "Failed jobs retry with exponential backoff up to maxAttempts"
    - "Shop redact deletes store record (cascading all matrices, option groups, draft orders)"
    - "Customer redact marks GDPR request as processed (acknowledgment only, no customer PII stored)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "JobQueue model for async job processing"
      contains: "model JobQueue"
    - path: "app/services/job-queue.server.ts"
      provides: "enqueueJob and processNextJob functions"
      exports: ["enqueueJob", "processNextJob"]
    - path: "app/services/gdpr-deletion.server.ts"
      provides: "GDPR deletion handlers for shop_redact and customer_redact"
      exports: ["processShopRedact", "processCustomerRedact"]
  key_links:
    - from: "app/services/job-queue.server.ts"
      to: "prisma.jobQueue"
      via: "Prisma client for job storage"
      pattern: "prisma\\.jobQueue\\.(create|findFirst|update)"
    - from: "app/services/gdpr-deletion.server.ts"
      to: "prisma.store"
      via: "Cascade delete of store and all related data"
      pattern: "prisma\\.store\\.deleteMany"
    - from: "app/services/job-queue.server.ts"
      to: "app/services/gdpr-deletion.server.ts"
      via: "executeJob dispatches to GDPR handlers by job type"
      pattern: "processShopRedact|processCustomerRedact"
---

<objective>
Add database-backed job queue infrastructure and GDPR deletion logic for async webhook processing.

Purpose: GDPR webhooks must respond within 200ms. Long-running deletions (cascade delete of store + matrices + option groups + draft orders) need async processing via a job queue. This plan creates the foundation: the JobQueue database model, the queue service (enqueue/process), and the actual deletion logic.

Output: JobQueue Prisma model with migration, job-queue.server.ts service, gdpr-deletion.server.ts service.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-graphql-migration-gdpr/15-RESEARCH.md
@prisma/schema.prisma
@app/routes/webhooks.tsx
@app/services/draft-order.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JobQueue model to Prisma schema and run migration</name>
  <files>prisma/schema.prisma</files>
  <action>
Add JobQueue model to prisma/schema.prisma after the existing GdprRequest model:

```prisma
model JobQueue {
  id          String    @id @default(cuid())
  type        String
  payload     Json
  status      String    @default("pending")
  attempts    Int       @default(0)
  maxAttempts Int       @default(3) @map("max_attempts")
  scheduledAt DateTime  @default(now()) @map("scheduled_at")
  processedAt DateTime? @map("processed_at")
  error       String?
  createdAt   DateTime  @default(now()) @map("created_at")

  @@index([status, scheduledAt])
  @@map("job_queue")
}
```

Fields:
- `type`: Job type string (e.g., "shop_redact", "customer_redact")
- `payload`: JSON payload with job-specific data (shop name, etc.)
- `status`: "pending" | "processing" | "completed" | "failed"
- `attempts`: Number of processing attempts so far
- `maxAttempts`: Maximum retry attempts (default 3)
- `scheduledAt`: When the job is eligible for processing (used for exponential backoff retry scheduling)
- `processedAt`: When the job completed successfully
- `error`: Last error message for failed jobs

Index on [status, scheduledAt] for efficient polling queries.

After adding the model, generate and apply the migration:
```bash
npx prisma migrate dev --name add_job_queue
```

Verify the migration succeeds and the Prisma client regenerates.
  </action>
  <verify>
Run `npx prisma migrate status` to confirm migration is applied. Run `npx prisma validate` to confirm schema is valid.
  </verify>
  <done>JobQueue model exists in schema.prisma with all fields, migration applied, Prisma client regenerated.</done>
</task>

<task type="auto">
  <name>Task 2: Create job queue service with enqueue and process functions</name>
  <files>app/services/job-queue.server.ts</files>
  <action>
Create `app/services/job-queue.server.ts` with two exported functions:

**enqueueJob(type: string, payload: Record&lt;string, unknown&gt;): Promise&lt;string&gt;**
- Creates a new JobQueue record with status "pending"
- Returns the job ID
- This is called from webhook handlers and must be fast (<50ms)

**processNextJob(): Promise&lt;{ processed: boolean; jobId?: string; type?: string; error?: string }&gt;**
- Uses a Prisma transaction to atomically claim the next pending job:
  1. Find first job where status="pending" AND scheduledAt <= now()
  2. If found, update status to "processing" and increment attempts
  3. Return the claimed job (or null if no jobs available)
- Execute the job by calling `executeJob(job.type, job.payload)` (internal dispatch function)
- On success: update status to "completed", set processedAt to now()
- On failure: if attempts >= maxAttempts, set status to "failed" with error message. Otherwise set status back to "pending" with scheduledAt set to `Date.now() + Math.pow(2, job.attempts) * 1000` (exponential backoff: 2s, 4s, 8s)
- Return result object indicating what happened

**Internal: executeJob(type: string, payload: any): Promise&lt;void&gt;**
- Switch on job type:
  - "shop_redact" -> call processShopRedact(payload) from gdpr-deletion.server.ts
  - "customer_redact" -> call processCustomerRedact(payload) from gdpr-deletion.server.ts
  - Default: throw Error("Unknown job type: {type}")

Import prisma from "~/db.server". Import GDPR handlers from "./gdpr-deletion.server".

Add console.log statements for: job enqueued, job claimed, job completed, job failed, no jobs available.
  </action>
  <verify>
File exists at app/services/job-queue.server.ts. TypeScript compiles without errors: `npx tsc --noEmit --skipLibCheck 2>&1 | grep job-queue || echo "No errors"`.
  </verify>
  <done>job-queue.server.ts exports enqueueJob and processNextJob. enqueueJob creates pending job records. processNextJob atomically claims and processes jobs with retry logic and exponential backoff.</done>
</task>

<task type="auto">
  <name>Task 3: Create GDPR deletion service with shop and customer redact handlers</name>
  <files>app/services/gdpr-deletion.server.ts</files>
  <action>
Create `app/services/gdpr-deletion.server.ts` with two exported functions:

**processShopRedact(payload: { shop: string }): Promise&lt;void&gt;**
- Wraps deletion in a Prisma transaction for atomicity
- Delete the store record: `tx.store.deleteMany({ where: { shop: payload.shop } })`
  - This cascades to: matrices -> breakpoints, cells, productMatrices, draftOrderRecords; optionGroups -> optionChoices, productOptionGroups (all have onDelete: Cascade in schema)
- Mark all SHOP_REDACT GDPR requests for this shop as processed: `tx.gdprRequest.updateMany({ where: { shop: payload.shop, type: "SHOP_REDACT", processedAt: null }, data: { processedAt: new Date() } })`
- Log completion: `console.log(\`[GDPR] Shop redact completed for ${payload.shop}\`)`

**processCustomerRedact(payload: { shop: string; customer?: { id: string; email: string } }): Promise&lt;void&gt;**
- This app does NOT store customer-specific PII. Draft orders are product-based quotes, not tied to customer accounts.
- Mark all CUSTOMERS_REDACT GDPR requests for this shop as processed: `prisma.gdprRequest.updateMany({ where: { shop: payload.shop, type: "CUSTOMERS_REDACT", processedAt: null }, data: { processedAt: new Date() } })`
- Log: `console.log(\`[GDPR] Customer redact acknowledged for ${payload.shop} - no customer PII stored\`)`
- Add a code comment explaining WHY no deletion is needed: "This app stores product-based pricing data (matrices, option groups, draft order quotes). No customer-specific PII is stored. If the app adds customer data in the future, add deletion logic here."

Import prisma from "~/db.server". Import GdprRequestType from "@prisma/client".
  </action>
  <verify>
File exists at app/services/gdpr-deletion.server.ts. TypeScript compiles: `npx tsc --noEmit --skipLibCheck 2>&1 | grep gdpr-deletion || echo "No errors"`.
  </verify>
  <done>gdpr-deletion.server.ts exports processShopRedact (cascade delete via store.deleteMany in transaction) and processCustomerRedact (acknowledgment-only with explanation comment). Both mark GDPR requests as processed.</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes (schema valid with JobQueue model)
2. `npx prisma migrate status` shows all migrations applied
3. `npx tsc --noEmit --skipLibCheck` compiles without errors in new service files
4. job-queue.server.ts exports enqueueJob and processNextJob
5. gdpr-deletion.server.ts exports processShopRedact and processCustomerRedact
</verification>

<success_criteria>
- JobQueue model exists in Prisma schema with status/scheduledAt index
- Migration applied successfully
- Job queue service can enqueue jobs and process them with atomic claiming
- GDPR deletion service handles shop_redact (cascade delete) and customer_redact (acknowledgment)
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-graphql-migration-gdpr/15-01-SUMMARY.md`
</output>
