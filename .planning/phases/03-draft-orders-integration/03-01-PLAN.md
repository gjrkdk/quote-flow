---
phase: 03-draft-orders-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - app/services/price-calculator.server.ts
  - app/services/price-calculator.server.test.ts
autonomous: true

must_haves:
  truths:
    - "Price calculator returns correct price for exact breakpoint dimensions"
    - "Price calculator rounds up to next higher breakpoint for between-breakpoint dimensions"
    - "Price calculator clamps to largest breakpoint price for dimensions above max"
    - "Price calculator clamps to smallest breakpoint price for dimensions below min"
    - "Price calculator rejects zero and negative dimensions with error"
    - "Price calculator validates quantity as positive integer"
  artifacts:
    - path: "app/services/price-calculator.server.ts"
      provides: "Price calculation logic with dimension validation and breakpoint lookup"
      exports: ["calculatePrice", "validateDimensions"]
      min_lines: 60
    - path: "app/services/price-calculator.server.test.ts"
      provides: "Test suite covering all edge cases"
      min_lines: 80
  key_links:
    - from: "app/services/price-calculator.server.ts"
      to: "Prisma MatrixCell/Breakpoint models"
      via: "position-based breakpoint lookup matching database schema"
      pattern: "widthPosition.*heightPosition"
---

<objective>
Build the price calculation service that looks up matrix prices given width, height, and matrix data. This is the core business logic for Phase 3 -- given customer dimensions and a price matrix, return the correct unit price.

Purpose: Price calculation is the foundation for Draft Order creation. Without correct price lookup, orders would have wrong prices. TDD ensures all edge cases (clamping, rounding up, rejection) match user decisions exactly.

Output: Tested `price-calculator.server.ts` with `calculatePrice()` and `validateDimensions()` functions.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-draft-orders-integration/03-CONTEXT.md
@.planning/phases/03-draft-orders-integration/03-RESEARCH.md
@prisma/schema.prisma
</context>

<feature>
  <name>Price Calculator Service</name>
  <files>app/services/price-calculator.server.ts, app/services/price-calculator.server.test.ts</files>
  <behavior>
    The price calculator takes customer dimensions (width, height) and matrix data (breakpoints + cells) and returns the calculated unit price.

    **Input types:**
    ```typescript
    interface MatrixData {
      widthBreakpoints: Array<{ position: number; value: number }>;
      heightBreakpoints: Array<{ position: number; value: number }>;
      cells: Array<{ widthPosition: number; heightPosition: number; price: number }>;
    }
    ```

    **validateDimensions(width, height, quantity):**
    - width <= 0 or height <= 0 -> { valid: false, error: "Width and height must be positive numbers" }
    - quantity <= 0 or not integer -> { valid: false, error: "Quantity must be a positive integer" }
    - valid inputs -> { valid: true }

    **calculatePrice(width, height, matrixData):**

    Test cases (using matrix with width breakpoints [300, 600, 900] and height breakpoints [200, 400, 600]):
    - Exact match: (300, 200) -> price at position (0, 0)
    - Exact match: (600, 400) -> price at position (1, 1)
    - Round up width: (450, 200) -> price at position (1, 0) — 450 rounds up to 600
    - Round up height: (300, 350) -> price at position (0, 1) — 350 rounds up to 400
    - Round up both: (450, 350) -> price at position (1, 1)
    - Below smallest width: (100, 200) -> price at position (0, 0) — clamps to smallest
    - Below smallest height: (300, 50) -> price at position (0, 0) — clamps to smallest
    - Below both: (50, 50) -> price at position (0, 0)
    - Above largest width: (1200, 200) -> price at position (2, 0) — clamps to largest
    - Above largest height: (300, 800) -> price at position (0, 2) — clamps to largest
    - Above both: (1200, 800) -> price at position (2, 2)
    - Missing cell throws error

    These test cases implement the user decisions from CONTEXT.md:
    - Between-breakpoint dimensions: always round UP to next higher breakpoint
    - Dimensions above largest: clamp to largest breakpoint price
    - Dimensions below smallest: clamp to smallest breakpoint price
    - Zero/negative: rejected by validateDimensions (called before calculatePrice)
  </behavior>
  <implementation>
    1. Create `app/services/` directory (does not exist yet)
    2. Create test file first with vitest (check if vitest is configured; if not, use Node test runner or install vitest)
    3. Implement `validateDimensions()` -- pure function, no database
    4. Implement `calculatePrice()` -- takes pre-fetched matrix data (no Prisma dependency in the function itself, data is passed in)
    5. Sort breakpoints by position, use findIndex for round-up logic
    6. Export `MatrixData` interface for use by draft-order service

    **Important implementation details:**
    - Breakpoints must be sorted by position before lookup (sort by `position` ascending)
    - `findIndex(bp => dimension <= bp.value)` naturally handles "round up" -- first breakpoint >= dimension
    - If findIndex returns -1 (above all breakpoints), clamp to last position (length - 1)
    - If findIndex returns 0 and dimension < first breakpoint, that's "below smallest" -- position 0 is correct (natural clamping)
    - Use the `.value` property for comparison but the `.position` property for cell lookup

    **Testing setup:** Check if vitest is available. If not, check for existing test setup. If no test framework is configured, install vitest as devDependency and add minimal vitest config. The project uses Vite already so vitest integrates naturally.
  </implementation>
</feature>

<verification>
- All tests pass: `npx vitest run app/services/price-calculator.server.test.ts`
- TypeScript compiles: `npx tsc --noEmit`
- Exports are correct: `calculatePrice` and `validateDimensions` exported from module
</verification>

<success_criteria>
- Price calculator correctly handles all 11+ test cases covering exact match, round up, clamp below, clamp above, and error scenarios
- validateDimensions rejects zero, negative, and non-integer quantity inputs
- All tests pass without mocking (pure functions with injected data)
- TypeScript types align with Prisma schema (widthPosition, heightPosition, price fields)
</success_criteria>

<output>
After completion, create `.planning/phases/03-draft-orders-integration/03-01-SUMMARY.md`
</output>
