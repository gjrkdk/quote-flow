---
phase: 04-public-rest-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/utils/api-auth.server.ts
  - app/utils/rate-limit.server.ts
  - app/validators/api.validators.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "authenticateApiKey throws 401 JSON response when X-API-Key header is missing"
    - "authenticateApiKey throws 401 JSON response when API key is invalid (wrong hash)"
    - "authenticateApiKey returns store object when API key is valid (timing-safe compare)"
    - "PriceQuerySchema validates width/height as positive numbers and coerces string query params"
    - "PriceQuerySchema rejects missing or non-numeric width/height"
    - "Rate limiter exports a function that can check request limits per store"
  artifacts:
    - path: "app/utils/api-auth.server.ts"
      provides: "API key authentication middleware for public endpoints"
      exports: ["authenticateApiKey"]
    - path: "app/validators/api.validators.ts"
      provides: "Zod validation schemas for API input"
      exports: ["PriceQuerySchema", "ProductIdSchema"]
    - path: "app/utils/rate-limit.server.ts"
      provides: "In-memory rate limiting per API key prefix"
      exports: ["checkRateLimit", "RateLimitError"]
  key_links:
    - from: "app/utils/api-auth.server.ts"
      to: "app/utils/api-key.server.ts"
      via: "imports verifyApiKey for timing-safe comparison"
      pattern: "import.*verifyApiKey.*from.*api-key\\.server"
    - from: "app/utils/api-auth.server.ts"
      to: "app/db.server.ts"
      via: "imports prisma for store lookup by apiKeyPrefix"
      pattern: "import.*prisma.*from.*db\\.server"
---

<objective>
Create the authentication, validation, and rate-limiting foundation for the public REST API.

Purpose: These utility modules are the building blocks that the REST endpoint (Plan 02) will compose. Separating them enables clean, testable code with single-responsibility modules.

Output:
- `api-auth.server.ts` — authenticate external requests via X-API-Key header
- `api.validators.ts` — Zod schemas for query parameter validation
- `rate-limit.server.ts` — in-memory per-store rate limiting
- Zod dependency installed
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-public-rest-api/04-RESEARCH.md
@app/utils/api-key.server.ts
@app/db.server.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create Zod validation schemas</name>
  <files>package.json, app/validators/api.validators.ts</files>
  <action>
    Install zod: `npm install zod`

    Create `app/validators/api.validators.ts` with two Zod schemas:

    1. **PriceQuerySchema** — validates query parameters for the price endpoint:
       - `width`: `z.coerce.number().positive("Width must be a positive number")` — coerces string query params to numbers
       - `height`: `z.coerce.number().positive("Height must be a positive number")` — same coercion
       - `quantity`: `z.coerce.number().int().positive().default(1)` — optional, defaults to 1

    2. **ProductIdSchema** — validates the productId URL parameter:
       - Accept numeric strings (e.g., "12345") via regex `^\d+$`
       - Accept full GID format (e.g., "gid://shopify/Product/12345") via regex `^gid:\/\/shopify\/Product\/\d+$`
       - Use `z.string().regex()` with a union or a custom refinement
       - Export a helper `normalizeProductId(id: string): string` that converts numeric IDs to GID format: if the ID doesn't start with "gid://", prepend "gid://shopify/Product/". This matches how productId is stored in the ProductMatrix table.

    Export both schemas and the normalizeProductId helper.
  </action>
  <verify>
    - `npx tsc --noEmit --skipLibCheck` compiles without errors in the new file
    - `node -e "require('zod')"` confirms zod is installed (or check package.json)
  </verify>
  <done>
    - Zod is installed as a dependency
    - PriceQuerySchema coerces string params to validated numbers
    - ProductIdSchema accepts both numeric and GID product IDs
    - normalizeProductId converts numeric IDs to GID format
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API authentication middleware</name>
  <files>app/utils/api-auth.server.ts</files>
  <action>
    Create `app/utils/api-auth.server.ts` that exports `authenticateApiKey(request: Request)`.

    Implementation:

    1. Extract `X-API-Key` header from request. If missing, throw a JSON response with status 401 and RFC 7807 format:
       ```
       { type: "about:blank", title: "Unauthorized", status: 401, detail: "X-API-Key header is required" }
       ```
       Use `import { json } from "@remix-run/node"` and `throw json(body, { status: 401 })`.

    2. Extract the prefix using `getApiKeyPrefix()` from existing `api-key.server.ts` (first 8 chars). Look up store in database:
       ```typescript
       const store = await prisma.store.findFirst({
         where: { apiKeyPrefix: prefix },
         select: { id: true, shop: true, apiKeyHash: true, unitPreference: true }
       });
       ```

    3. If no store found OR store has no apiKeyHash, throw 401 with detail "Invalid API key".

    4. Verify using `verifyApiKey(apiKey, store.apiKeyHash)` from existing `api-key.server.ts`. If false, throw 401 with detail "Invalid API key".

    5. Return the store object (with id, shop, unitPreference) on success.

    IMPORTANT:
    - Do NOT log the full API key. Only log the prefix for debugging.
    - Use the SAME generic "Invalid API key" message for both missing store and wrong key (prevents enumeration).
    - All error responses must use RFC 7807 format with `type`, `title`, `status`, `detail` fields.
    - Import `json` from `@remix-run/node`, `verifyApiKey` and `getApiKeyPrefix` from `~/utils/api-key.server`, `prisma` from `~/db.server`.
  </action>
  <verify>
    - File exists at `app/utils/api-auth.server.ts`
    - Exports `authenticateApiKey` function
    - Uses `verifyApiKey` from api-key.server.ts (not custom comparison)
    - Uses `getApiKeyPrefix` from api-key.server.ts
    - Returns store with id, shop, unitPreference on success
    - Throws json 401 for missing header, invalid key
  </verify>
  <done>
    - authenticateApiKey extracts X-API-Key header and verifies against stored hash
    - Returns store object (id, shop, unitPreference) on success
    - Throws 401 RFC 7807 JSON response on failure (missing header or invalid key)
    - Uses timing-safe comparison via existing verifyApiKey utility
  </done>
</task>

<task type="auto">
  <name>Task 3: Create in-memory rate limiting utility</name>
  <files>app/utils/rate-limit.server.ts</files>
  <action>
    Create `app/utils/rate-limit.server.ts` with a simple in-memory rate limiter.

    Do NOT use express-rate-limit (it requires Express middleware integration which doesn't work cleanly with Remix resource routes). Instead, implement a lightweight in-memory rate limiter:

    1. **Data structure:** `Map<string, { count: number; resetAt: number }>` keyed by store ID (not IP, since we authenticate by API key).

    2. **Configuration constants:**
       - `WINDOW_MS = 15 * 60 * 1000` (15 minutes)
       - `MAX_REQUESTS = 100` (per store per window)

    3. **Export `checkRateLimit(storeId: string): void`:**
       - Look up store's entry in the map
       - If no entry or entry expired (Date.now() > resetAt), create new entry with count=1 and resetAt=Date.now()+WINDOW_MS
       - If entry exists and not expired, increment count
       - If count > MAX_REQUESTS, throw a JSON 429 response with RFC 7807 format:
         ```
         { type: "about:blank", title: "Too Many Requests", status: 429, detail: "Rate limit exceeded. Try again later." }
         ```
         Include `Retry-After` header with remaining seconds until window reset.

    4. **Export `getRateLimitHeaders(storeId: string)` utility** that returns headers object with:
       - `X-RateLimit-Limit`: MAX_REQUESTS
       - `X-RateLimit-Remaining`: remaining requests
       - `X-RateLimit-Reset`: Unix timestamp of window reset

    5. Add a module-level cleanup: periodically (every 5 minutes) remove expired entries to prevent memory leaks. Use `setInterval` with `unref()` so it doesn't keep the process alive.

    Add a comment at the top: `// NOTE: In-memory rate limiting. Only works for single-instance deployments. For multi-instance, migrate to Redis.`
  </action>
  <verify>
    - File exists at `app/utils/rate-limit.server.ts`
    - Exports `checkRateLimit` and `getRateLimitHeaders`
    - Uses Map for storage, not external dependencies
    - Throws 429 with Retry-After header when limit exceeded
  </verify>
  <done>
    - In-memory rate limiter tracks requests per store ID within 15-minute windows
    - checkRateLimit throws 429 RFC 7807 response when limit exceeded
    - getRateLimitHeaders returns standard rate limit headers
    - Periodic cleanup prevents memory leaks
    - Documented as single-instance only with Redis migration note
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls zod` confirms zod is installed
2. All three new files exist and export expected functions
3. No TypeScript errors in the new files (check with `npx tsc --noEmit --skipLibCheck` or read the files for import correctness)
</verification>

<success_criteria>
- Zod installed as dependency
- api-auth.server.ts authenticates requests and returns store or throws 401
- api.validators.ts provides Zod schemas for price query and product ID validation
- rate-limit.server.ts provides per-store rate limiting with 429 responses
- All error responses follow RFC 7807 format
- No new external dependencies beyond zod (rate limiting is in-memory)
</success_criteria>

<output>
After completion, create `.planning/phases/04-public-rest-api/04-01-SUMMARY.md`
</output>
