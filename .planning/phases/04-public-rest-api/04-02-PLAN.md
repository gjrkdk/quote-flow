---
phase: 04-public-rest-api
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/services/product-matrix-lookup.server.ts
  - app/routes/api.v1.products.$productId.price.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/products/:id/price?width=300&height=200 with valid API key returns JSON with price"
    - "GET /api/v1/products/:id/price without X-API-Key returns 401 Unauthorized"
    - "GET /api/v1/products/:id/price with invalid dimensions returns 400 with validation errors"
    - "GET /api/v1/products/:id/price for product with no matrix returns 404"
    - "Dimensions between breakpoints round up to next higher breakpoint price"
    - "Response includes CORS headers allowing cross-origin requests"
    - "Response includes rate limit headers"
  artifacts:
    - path: "app/services/product-matrix-lookup.server.ts"
      provides: "Database lookup for product matrix with breakpoints and cells"
      exports: ["lookupProductMatrix"]
    - path: "app/routes/api.v1.products.$productId.price.ts"
      provides: "GET /api/v1/products/:productId/price REST endpoint"
      exports: ["loader"]
  key_links:
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/utils/api-auth.server.ts"
      via: "authenticateApiKey for request authentication"
      pattern: "import.*authenticateApiKey.*from.*api-auth\\.server"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/validators/api.validators.ts"
      via: "Zod schemas for input validation"
      pattern: "import.*PriceQuerySchema.*from.*api\\.validators"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/services/product-matrix-lookup.server.ts"
      via: "lookupProductMatrix for database query"
      pattern: "import.*lookupProductMatrix.*from.*product-matrix-lookup\\.server"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/services/price-calculator.server.ts"
      via: "calculatePrice and validateDimensions for business logic"
      pattern: "import.*calculatePrice.*from.*price-calculator\\.server"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/utils/rate-limit.server.ts"
      via: "checkRateLimit and getRateLimitHeaders for rate limiting"
      pattern: "import.*checkRateLimit.*from.*rate-limit\\.server"
---

<objective>
Create the public REST API endpoint for dimension-based price lookups and the product-matrix-lookup service.

Purpose: This is the core deliverable of Phase 4 — external headless storefronts can now authenticate and retrieve prices via a clean REST API. The endpoint composes the authentication, validation, rate-limiting, and pricing services created in Plan 01 (and Phase 3).

Output:
- `product-matrix-lookup.server.ts` — database service to fetch a product's matrix with breakpoints and cells
- `api.v1.products.$productId.price.ts` — REST resource route handling GET requests with full auth, validation, rate limiting, CORS, and pricing
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-public-rest-api/04-RESEARCH.md
@.planning/phases/04-public-rest-api/04-01-SUMMARY.md
@app/services/price-calculator.server.ts
@app/services/draft-order.server.ts
@app/db.server.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product-matrix-lookup service</name>
  <files>app/services/product-matrix-lookup.server.ts</files>
  <action>
    Create `app/services/product-matrix-lookup.server.ts` that exports `lookupProductMatrix(productId: string, storeId: string)`.

    This service encapsulates the database query to find a product's assigned matrix with all its breakpoints and cells, and transforms the result into the `MatrixData` format expected by `calculatePrice()`.

    Implementation:

    1. **Query the database:**
       ```typescript
       const productMatrix = await prisma.productMatrix.findUnique({
         where: { productId },
         include: {
           matrix: {
             include: {
               widthBreakpoints: true,  // This is the Breakpoint model, contains BOTH axes
               cells: true,
             },
           },
         },
       });
       ```

    2. **Validate ownership:** Check that `productMatrix.matrix.storeId === storeId`. If not, return null (prevents cross-store access).

    3. **Transform to MatrixData:** Follow the EXACT same pattern from `draft-order.server.ts` (lines 138-158):
       - Filter `widthBreakpoints` by `axis === "width"`, sort by position, map to `{ position, value }`
       - Filter `widthBreakpoints` by `axis === "height"`, sort by position, map to `{ position, value }`
       - Map cells to `{ widthPosition, heightPosition, price }`

    4. **Return type:**
       ```typescript
       interface ProductMatrixResult {
         matrixData: MatrixData;
         matrixName: string;
       }
       ```
       Return `null` if no ProductMatrix found for the productId, or if the matrix belongs to a different store.

    Import `MatrixData` from `~/services/price-calculator.server` and `prisma` from `~/db.server`.

    IMPORTANT: The `productId` parameter should already be in GID format (normalized by the route). The `storeId` comes from the authenticated store.
  </action>
  <verify>
    - File exists at `app/services/product-matrix-lookup.server.ts`
    - Exports `lookupProductMatrix` function
    - Returns `{ matrixData, matrixName }` or `null`
    - Validates store ownership (cross-store access prevention)
    - Transforms Prisma result to MatrixData format matching price-calculator.server.ts interface
  </verify>
  <done>
    - lookupProductMatrix queries ProductMatrix by productId with matrix+breakpoints+cells included
    - Validates that matrix belongs to the authenticated store
    - Returns MatrixData in the exact format expected by calculatePrice()
    - Returns null for missing product or cross-store access
  </done>
</task>

<task type="auto">
  <name>Task 2: Create REST endpoint resource route with CORS</name>
  <files>app/routes/api.v1.products.$productId.price.ts</files>
  <action>
    Create `app/routes/api.v1.products.$productId.price.ts` as a Remix resource route (NO default export = REST endpoint).

    This route handles GET requests to `/api/v1/products/:productId/price?width=X&height=Y&quantity=Z`.

    **Export only a `loader` function** (handles GET requests):

    ```typescript
    import { json, type LoaderFunctionArgs } from "@remix-run/node";
    ```

    **Request flow (in order):**

    1. **CORS preflight:** Handle OPTIONS requests first. If `request.method === "OPTIONS"`, return a 204 response with CORS headers:
       - `Access-Control-Allow-Origin: *` (API key is primary auth; CORS is defense-in-depth)
       - `Access-Control-Allow-Methods: GET, OPTIONS`
       - `Access-Control-Allow-Headers: X-API-Key, Content-Type`
       - `Access-Control-Max-Age: 86400`

       Wait — resource routes use `loader` for GET and `action` for POST. OPTIONS is neither. To handle OPTIONS, export a `loader` that checks `request.method`. Actually, in Remix resource routes the `loader` only handles GET/HEAD. For OPTIONS we need a different approach.

       REVISED approach for CORS: Instead of handling OPTIONS in the loader, add CORS headers to ALL responses from the loader. For the OPTIONS preflight, we need a workaround. The simplest approach: add a middleware-style CORS header helper function that wraps the response. Since this is a Remix resource route and the Shopify CLI proxy will be in front, we handle CORS at the response level:

       Create a helper function `withCors(response: Response): Response` at the top of the file:
       ```typescript
       function withCors(response: Response): Response {
         response.headers.set("Access-Control-Allow-Origin", "*");
         response.headers.set("Access-Control-Allow-Methods", "GET, OPTIONS");
         response.headers.set("Access-Control-Allow-Headers", "X-API-Key, Content-Type");
         return response;
       }
       ```

       Also export an `action` function that handles non-GET methods and returns 405 Method Not Allowed with CORS headers. This will catch OPTIONS requests too. Actually, Remix routes actions for POST/PUT/PATCH/DELETE but not OPTIONS. The simplest reliable approach: just add CORS headers to all loader responses. Browser preflight (OPTIONS) may need server-level handling, but for the MVP with API-key-based auth, most clients will be server-to-server (not browser). Document this limitation.

       FINAL approach: Add CORS headers to all responses. Export both `loader` (GET) and `action` (POST/PUT/DELETE/PATCH to return 405). For OPTIONS, rely on the fact that if a Remix action receives an OPTIONS request, it will process it. Actually, in Remix, the `action` handles OPTIONS too. So:
       - Export `action` that returns 204 with CORS headers for OPTIONS, 405 for others
       - Export `loader` that handles GET with CORS headers on all responses

    2. **Rate limiting:** Call `checkRateLimit(store.id)` from `rate-limit.server.ts`. This throws 429 if exceeded. Wrap in try/catch — if it throws a Response, add CORS headers and re-throw.

    3. **Authentication:** Call `authenticateApiKey(request)` from `api-auth.server.ts`. This throws 401 if invalid. Returns `store` with `id`, `shop`, `unitPreference`.

    4. **Validate product ID:** Use `ProductIdSchema.safeParse(params.productId)`. If invalid, throw 400 with RFC 7807 error:
       ```
       { type: "about:blank", title: "Bad Request", status: 400, detail: "Invalid product ID format" }
       ```
       Then call `normalizeProductId()` to convert to GID format.

    5. **Validate query parameters:** Parse `width`, `height`, `quantity` from URL search params. Use `PriceQuerySchema.safeParse()`. If invalid, throw 400 with validation errors in RFC 7807 format:
       ```
       { type: "about:blank", title: "Validation Failed", status: 400, detail: "Invalid query parameters", errors: result.error.flatten().fieldErrors }
       ```

    6. **Validate dimensions (business logic):** Call `validateDimensions(width, height, quantity)` from `price-calculator.server.ts`. If invalid, throw 400 with the validation error message.

    7. **Look up product matrix:** Call `lookupProductMatrix(normalizedProductId, store.id)` from `product-matrix-lookup.server.ts`. If null, throw 404:
       ```
       { type: "about:blank", title: "Not Found", status: 404, detail: "No price matrix assigned to this product" }
       ```

    8. **Calculate price:** Call `calculatePrice(width, height, matrixData)` from `price-calculator.server.ts`. Wrap in try/catch — if it throws (missing cell), return 500 internal error.

    9. **Return success response** with CORS and rate-limit headers:
       ```json
       {
         "price": 25.00,
         "currency": "store-default",
         "dimensions": {
           "width": 450,
           "height": 350,
           "unit": "mm"
         },
         "quantity": 1,
         "total": 25.00,
         "matrix": "Matrix Name"
       }
       ```
       Note: `price` is unit price, `total` is price * quantity.

    10. **Global error handler:** Wrap the entire loader body in try/catch. If error is a Response (thrown by auth, validation, rate limit), add CORS headers and re-throw. If error is unexpected, return 500 with generic RFC 7807 error. Never expose internal details.

    **Important patterns:**
    - All thrown responses use `json()` from `@remix-run/node`
    - Every response (success AND error) gets CORS headers via `withCors()`
    - Rate limit headers added to success responses via `getRateLimitHeaders()`
    - No default component export (this is a resource route, NOT a page)
  </action>
  <verify>
    - File exists at `app/routes/api.v1.products.$productId.price.ts`
    - Exports `loader` function (GET handler)
    - Exports `action` function (OPTIONS/405 handler)
    - No default export (resource route, not page)
    - Imports from api-auth.server, api.validators, rate-limit.server, product-matrix-lookup.server, price-calculator.server
    - CORS headers on all responses
    - Rate limit headers on success responses
    - RFC 7807 error format on all error responses
    - `npx tsc --noEmit --skipLibCheck` passes for this file
  </verify>
  <done>
    - GET /api/v1/products/:productId/price returns price for valid requests
    - 401 for missing/invalid API key
    - 400 for invalid product ID, missing/invalid dimensions, out-of-range dimensions
    - 404 for product with no assigned matrix
    - 429 for rate-limited requests
    - 500 for unexpected internal errors (generic message)
    - CORS headers on all responses
    - Rate limit headers on success responses
    - All errors follow RFC 7807 format
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `app/services/product-matrix-lookup.server.ts` exists and exports `lookupProductMatrix`
2. `app/routes/api.v1.products.$productId.price.ts` exists and exports `loader` (no default export)
3. TypeScript compiles without errors: `npx tsc --noEmit --skipLibCheck`
4. Route file imports from all Plan 01 utilities (api-auth, validators, rate-limit) and existing services (price-calculator, product-matrix-lookup)
</verification>

<success_criteria>
- REST endpoint at /api/v1/products/:productId/price handles GET requests
- Endpoint authenticates via X-API-Key header (reuses existing api-key infrastructure)
- Input validated with Zod (width, height, quantity query params + product ID)
- Price calculated using existing price-calculator service (with round-up behavior)
- 404 returned for products without assigned matrix
- CORS headers present on all responses
- Rate limiting enforced per store
- All error responses follow RFC 7807 format
- Satisfies requirements API-01, API-02, API-03, API-04
</success_criteria>

<output>
After completion, create `.planning/phases/04-public-rest-api/04-02-SUMMARY.md`
</output>
