---
phase: 02-admin-matrix-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/
  - app/routes/app.settings.tsx
autonomous: true

must_haves:
  truths:
    - "PriceMatrix, Breakpoint, MatrixCell, and ProductMatrix tables exist in the database"
    - "Store model has a unitPreference field defaulting to 'mm'"
    - "Merchant can select mm or cm as their unit preference on the Settings page"
    - "Unit preference persists across page reloads"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Matrix data models with relations and cascade deletes"
      contains: "model PriceMatrix"
    - path: "app/routes/app.settings.tsx"
      provides: "Unit preference selector with save"
      min_lines: 40
  key_links:
    - from: "app/routes/app.settings.tsx"
      to: "prisma.store"
      via: "Remix action updating unitPreference"
      pattern: "prisma\\.store\\.update"
---

<objective>
Add the database schema for price matrices (PriceMatrix, Breakpoint, MatrixCell, ProductMatrix) and build the Settings page with store-wide unit preference (mm/cm).

Purpose: All subsequent plans depend on these database models. The unit preference must exist before matrix creation so the grid can display correct units.
Output: Migrated database with matrix tables, functional Settings page with unit selector.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@prisma/schema.prisma
@app/routes/app.settings.tsx
@app/db.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matrix models to Prisma schema and run migration</name>
  <files>prisma/schema.prisma, prisma/migrations/</files>
  <action>
Add the following models to `prisma/schema.prisma`, keeping existing Store and GdprRequest models intact:

1. Add `unitPreference String @default("mm")` field to the existing Store model.
2. Add a `matrices PriceMatrix[]` relation field to Store.

3. Create `PriceMatrix` model:
   - `id String @id @default(cuid())`
   - `storeId String`
   - `name String`
   - `createdAt DateTime @default(now())`
   - `updatedAt DateTime @updatedAt`
   - `store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)`
   - `widthBreakpoints Breakpoint[]` (relation filtered by axis in application code)
   - `cells MatrixCell[]`
   - `products ProductMatrix[]`
   - `@@index([storeId])`

4. Create `Breakpoint` model:
   - `id String @id @default(cuid())`
   - `matrixId String`
   - `axis String` — "width" or "height"
   - `value Float` — dimension value in the store's unit
   - `position Int` — 0-indexed sort order
   - `matrix PriceMatrix @relation(fields: [matrixId], references: [id], onDelete: Cascade)`
   - `@@unique([matrixId, axis, value])` — prevent duplicate breakpoint values per axis
   - `@@index([matrixId, axis])`

5. Create `MatrixCell` model:
   - `id String @id @default(cuid())`
   - `matrixId String`
   - `widthPosition Int` — index into width breakpoints
   - `heightPosition Int` — index into height breakpoints
   - `price Float`
   - `matrix PriceMatrix @relation(fields: [matrixId], references: [id], onDelete: Cascade)`
   - `@@unique([matrixId, widthPosition, heightPosition])` — one price per intersection
   - `@@index([matrixId])`

6. Create `ProductMatrix` model:
   - `id String @id @default(cuid())`
   - `matrixId String`
   - `productId String` — Shopify product GID (e.g., "gid://shopify/Product/12345")
   - `productTitle String` — cached product title for display without API call
   - `assignedAt DateTime @default(now())`
   - `matrix PriceMatrix @relation(fields: [matrixId], references: [id], onDelete: Cascade)`
   - `@@unique([productId])` — enforces one matrix per product (MATRIX-06)
   - `@@index([matrixId])`

Design note: Using position-based cell references (widthPosition/heightPosition) instead of value-based references. This makes the grid simpler — cells reference their position in the breakpoint arrays, not the breakpoint values themselves. When breakpoints are reordered or values change, cells stay correct as long as positions are maintained.

Run migration:
```bash
npx prisma migrate dev --name add_matrix_models
```

Verify migration succeeded and Prisma client regenerated.
  </action>
  <verify>
Run `npx prisma migrate status` — should show all migrations applied.
Run `npx prisma validate` — should show no errors.
Run `npx prisma db pull` and compare — schema should match.
  </verify>
  <done>All four matrix-related tables (PriceMatrix, Breakpoint, MatrixCell, ProductMatrix) exist in PostgreSQL with correct columns, constraints, indexes, and cascade delete relations. Store model has unitPreference field.</done>
</task>

<task type="auto">
  <name>Task 2: Build Settings page with unit preference selector</name>
  <files>app/routes/app.settings.tsx</files>
  <action>
Replace the placeholder Settings page with a functional unit preference selector.

The page should:

1. **Loader:** Authenticate, fetch the store's current `unitPreference` from the database. Return it as loader data.

2. **Action:** Handle POST with `intent: "update-unit"` and `unit: "mm" | "cm"`. Validate that unit is either "mm" or "cm". Update `prisma.store.update({ where: { shop }, data: { unitPreference: unit } })`. Return success JSON.

3. **UI (Polaris components):**
   - `Page` with title "Settings" and `backAction={{ url: "/app" }}`
   - `Layout` with one `Layout.AnnotatedSection`:
     - Title: "Measurement units"
     - Description: "Choose the unit of measurement for all your pricing matrices. This applies to all matrices in your store."
   - Inside the section, a `Card` containing:
     - `Select` component with label "Unit" and options: `[{ label: "Millimeters (mm)", value: "mm" }, { label: "Centimeters (cm)", value: "cm" }]`
     - Current value from loader data
     - On change: submit form via `useFetcher` (not full page navigation)
   - Show `Banner` with tone="success" briefly when save succeeds (use fetcher.data)

4. **Auto-save pattern:** When the Select value changes, immediately submit via fetcher. No separate save button needed for a single toggle — this is a simple preference, not a complex form.

Use Polaris `Select`, `Card`, `Layout.AnnotatedSection`, `Page`, `Banner`.
Use Remix `useFetcher` for the submission (no page reload).
  </action>
  <verify>
Start dev server (`shopify app dev`). Navigate to Settings page.
- Default value should be "mm"
- Changing to "cm" should save without page reload
- Refreshing should show "cm" persisted
- Changing back to "mm" should also persist
  </verify>
  <done>Settings page shows unit preference selector (mm/cm). Changing the value persists to database immediately. Value survives page reload.</done>
</task>

</tasks>

<verification>
1. `npx prisma migrate status` shows all migrations applied
2. `npx prisma validate` passes
3. Settings page loads without errors
4. Unit preference saves and persists
</verification>

<success_criteria>
- Database has PriceMatrix, Breakpoint, MatrixCell, ProductMatrix tables with proper constraints
- Store model has unitPreference field defaulting to "mm"
- Settings page allows toggling between mm and cm
- Cascade deletes configured (deleting a matrix removes its breakpoints, cells, and product assignments)
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-matrix-management/02-01-SUMMARY.md`
</output>
