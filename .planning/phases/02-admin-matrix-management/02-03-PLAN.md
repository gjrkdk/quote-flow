---
phase: 02-admin-matrix-management
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - app/routes/app.matrices.$id.edit.tsx
  - app/components/MatrixGrid.tsx
  - app/components/UnsavedChangesPrompt.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Merchant sees a spreadsheet-style editable grid with width breakpoints as columns and height breakpoints as rows"
    - "Merchant can click any cell and type a price value"
    - "Merchant can add a new width or height breakpoint via '+' button"
    - "Merchant can remove a width or height breakpoint via 'x' button"
    - "Breakpoints auto-sort ascending regardless of entry order"
    - "Merchant must fill all cells before saving — empty cells are highlighted"
    - "Save button persists all changes to the database atomically"
    - "Navigating away with unsaved changes shows a warning modal"
    - "Matrix size is capped at 50x50 breakpoints"
  artifacts:
    - path: "app/routes/app.matrices.$id.edit.tsx"
      provides: "Matrix editor route with grid, save, validation"
      min_lines: 150
    - path: "app/components/MatrixGrid.tsx"
      provides: "React Datasheet Grid wrapper for price matrix"
      min_lines: 80
    - path: "app/components/UnsavedChangesPrompt.tsx"
      provides: "useBlocker-based navigation guard modal"
      min_lines: 20
  key_links:
    - from: "app/routes/app.matrices.$id.edit.tsx"
      to: "prisma.priceMatrix"
      via: "loader fetches matrix with breakpoints and cells, action saves updates"
      pattern: "prisma\\.priceMatrix\\.(findUnique|update)"
    - from: "app/routes/app.matrices.$id.edit.tsx"
      to: "app/components/MatrixGrid.tsx"
      via: "import and render as controlled component"
      pattern: "import.*MatrixGrid"
    - from: "app/components/MatrixGrid.tsx"
      to: "react-datasheet-grid"
      via: "wraps DataSheetGrid with price matrix column definitions"
      pattern: "import.*DataSheetGrid"
---

<objective>
Build the matrix editor page with a spreadsheet-style editable grid using React Datasheet Grid. Merchants can edit prices inline, add/remove breakpoints, and save changes with full validation.

Purpose: This is the core UI of the app — the spreadsheet grid where merchants define their dimension-based pricing. It must feel like editing a mini Excel.
Output: Fully functional matrix editor with inline price editing, breakpoint management, validation, and unsaved changes protection.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-admin-matrix-management/02-RESEARCH.md
@.planning/phases/02-admin-matrix-management/02-01-SUMMARY.md
@.planning/phases/02-admin-matrix-management/02-02-SUMMARY.md
@prisma/schema.prisma
@app/db.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-datasheet-grid and build MatrixGrid and UnsavedChangesPrompt components</name>
  <files>package.json, app/components/MatrixGrid.tsx, app/components/UnsavedChangesPrompt.tsx</files>
  <action>
**1. Install react-datasheet-grid:**
```bash
npm install react-datasheet-grid
```

**2. Create `app/components/MatrixGrid.tsx`:**

This component wraps React Datasheet Grid for the price matrix use case. It receives breakpoints and cell data as props and calls back on changes.

Props interface:
```typescript
interface MatrixGridProps {
  widthBreakpoints: number[];      // sorted ascending
  heightBreakpoints: number[];     // sorted ascending
  cells: Map<string, number>;      // key: "col,row" -> price value
  unit: string;                    // "mm" or "cm"
  onCellChange: (col: number, row: number, value: number | null) => void;
  onAddWidthBreakpoint: (value: number) => void;
  onAddHeightBreakpoint: (value: number) => void;
  onRemoveWidthBreakpoint: (index: number) => void;
  onRemoveHeightBreakpoint: (index: number) => void;
  emptyCells: Set<string>;         // cells that failed validation (highlighted)
}
```

Implementation approach — DO NOT use DataSheetGrid's built-in column/row model for this because the matrix has a special structure (breakpoint labels on both axes). Instead, build a custom grid using an HTML table with inline-editable cells:

- Render a `<table>` with proper styling to look like a spreadsheet
- First column header row: empty corner cell, then each width breakpoint value with unit suffix and an "x" remove button
- A "+" button after the last width column header to add a new width breakpoint
- Each data row: first cell is the height breakpoint value with "x" remove button, then editable price cells
- After the last data row: a row with a "+" button to add a new height breakpoint
- Each price cell is an `<input type="number">` with `step="0.01"`, `min="0"`
- Style empty/invalid cells with a red border or background when they appear in `emptyCells`
- Tab between cells should work naturally (HTML table + inputs handle this)
- Style the table to look like a clean spreadsheet: borders, padding, monospace numbers, alternating row colors optional

**Important design decision:** The research recommended React Datasheet Grid, but for a 2D matrix with labeled axes (breakpoints as headers on BOTH axes), a custom HTML table with input cells is actually simpler and more appropriate. React Datasheet Grid is designed for flat tabular data with columns, not for a matrix where both axes are dynamic breakpoints. A custom table gives full control over the layout (corner cell, axis labels, +/x buttons) without fighting the library's data model. The max size is 50x50 = 2,500 cells, which is well within what a plain HTML table handles.

CSS: Create styles inline or as a CSS module. Key styles:
- `table { border-collapse: collapse; width: 100%; }`
- `td, th { border: 1px solid #e1e3e5; padding: 4px 8px; text-align: right; }`
- `th { background: #f6f6f7; font-weight: 600; }`
- `input { width: 80px; text-align: right; border: none; background: transparent; font-size: 14px; }`
- `input:focus { outline: 2px solid #2c6ecb; border-radius: 2px; }`
- `.empty-cell { background: #fff4f4; }` — for validation highlighting
- Button styles for +/x: small, subtle, with hover states

Memoize the component with `React.memo` to prevent unnecessary re-renders.

**3. Create `app/components/UnsavedChangesPrompt.tsx`:**

A simple component using Remix's `useBlocker` and Polaris `Modal`:

```typescript
import { useBlocker } from "@remix-run/react";
import { Modal, Text } from "@shopify/polaris";

interface UnsavedChangesPromptProps {
  isDirty: boolean;
}

export function UnsavedChangesPrompt({ isDirty }: UnsavedChangesPromptProps) {
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      isDirty && currentLocation.pathname !== nextLocation.pathname
  );

  if (blocker.state !== "blocked") return null;

  return (
    <Modal
      open={true}
      onClose={() => blocker.reset?.()}
      title="Unsaved changes"
      primaryAction={{
        content: "Leave page",
        onAction: () => blocker.proceed?.(),
        destructive: true,
      }}
      secondaryActions={[{
        content: "Stay",
        onAction: () => blocker.reset?.(),
      }]}
    >
      <Modal.Section>
        <Text as="p">You have unsaved changes. Are you sure you want to leave?</Text>
      </Modal.Section>
    </Modal>
  );
}
```
  </action>
  <verify>
- `npm ls react-datasheet-grid` shows installed (even though we ultimately use a custom grid, the package is available if needed)
- `app/components/MatrixGrid.tsx` exists and exports the component
- `app/components/UnsavedChangesPrompt.tsx` exists and exports the component
- TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>MatrixGrid component renders an editable spreadsheet-style table with breakpoint headers, +/x buttons for axis management, and validation highlighting. UnsavedChangesPrompt component provides navigation guard modal.</done>
</task>

<task type="auto">
  <name>Task 2: Build matrix editor route with full save and validation logic</name>
  <files>app/routes/app.matrices.$id.edit.tsx</files>
  <action>
Create `app/routes/app.matrices.$id.edit.tsx`:

**Loader:**
- Authenticate via `authenticate.admin(request)`
- Extract `id` from params
- Fetch store by `session.shop` (get unitPreference)
- Fetch matrix with all relations:
  ```typescript
  const matrix = await prisma.priceMatrix.findUnique({
    where: { id, storeId: store.id },
    include: {
      breakpoints: { orderBy: { position: "asc" } },
      cells: true,
      products: true,
    },
  });
  ```
- If matrix not found or belongs to different store, throw 404
- Separate breakpoints into width and height arrays by filtering on `axis`
- Build cell map: `{ "col,row": price }` from cells data
- Return: `{ matrix: { id, name }, widthBreakpoints, heightBreakpoints, cells, unit: store.unitPreference, products }`

**Action:**
Handle multiple intents via `formData.get("intent")`:

1. **`intent: "save"`** — Full matrix save
   - Parse JSON from `formData.get("data")`: `{ name, widthBreakpoints: number[], heightBreakpoints: number[], cells: { col: number, row: number, price: number }[] }`
   - **Validation (server-side):**
     - Name required, max 100 chars
     - Width breakpoints: 1-50 values, all positive numbers
     - Height breakpoints: 1-50 values, all positive numbers
     - All cells present: `widthBreakpoints.length * heightBreakpoints.length === cells.length`
     - All prices are positive numbers
   - If validation fails, return `json({ success: false, errors: [...] })`
   - **Save in transaction** (`prisma.$transaction`):
     1. Update matrix name: `prisma.priceMatrix.update({ where: { id }, data: { name } })`
     2. Delete all existing breakpoints: `prisma.breakpoint.deleteMany({ where: { matrixId: id } })`
     3. Delete all existing cells: `prisma.matrixCell.deleteMany({ where: { matrixId: id } })`
     4. Sort breakpoints ascending before saving
     5. Create new width breakpoints with positions 0, 1, 2...
     6. Create new height breakpoints with positions 0, 1, 2...
     7. Create new cells with widthPosition and heightPosition indices
   - Return `json({ success: true })`

2. **`intent: "rename"`** — Quick rename
   - Parse `name` from formData
   - Update: `prisma.priceMatrix.update({ where: { id }, data: { name } })`
   - Return `json({ success: true })`

**UI:**

```
Page layout:
┌────────────────────────────────────────┐
│ Page: "{matrix.name}" [Edit name]      │
│ backAction: /app/matrices              │
│                                        │
│ ┌─ Card: Price Grid ─────────────────┐ │
│ │                                    │ │
│ │  <MatrixGrid ... />                │ │
│ │                                    │ │
│ └────────────────────────────────────┘ │
│                                        │
│ ┌─ Card: Products ───────────────────┐ │
│ │  (Plan 04 will add content here)   │ │
│ │  Placeholder: "Product assignment  │ │
│ │  coming soon"                      │ │
│ └────────────────────────────────────┘ │
│                                        │
│ ┌─ PageActions ──────────────────────┐ │
│ │  [Save]  (primary, disabled if     │ │
│ │           not dirty or has errors) │ │
│ └────────────────────────────────────┘ │
└────────────────────────────────────────┘
```

Component state management:
- `widthBreakpoints: number[]` — from loader, updated locally
- `heightBreakpoints: number[]` — from loader, updated locally
- `cells: Map<string, number>` — key "col,row" -> price
- `name: string` — editable matrix name
- `isDirty: boolean` — tracks any change from loaded state
- `emptyCells: Set<string>` — cells with no price (for validation)
- `errors: string[]` — validation error messages

Breakpoint management handlers:
- `handleAddWidthBreakpoint`: Prompt for value (use a small inline TextField that appears when "+" clicked), validate it's a positive number, add to array. When a width breakpoint is added, add new cells for every existing height breakpoint with `null` price. Cap at 50 width breakpoints.
- `handleAddHeightBreakpoint`: Same logic for height axis. Cap at 50 height breakpoints.
- `handleRemoveWidthBreakpoint(index)`: Remove breakpoint at index, remove corresponding cells. Must have at least 1 breakpoint remaining.
- `handleRemoveHeightBreakpoint(index)`: Same for height.
- After any breakpoint add/remove, re-sort breakpoints ascending and re-index cells.

Cell change handler:
- `handleCellChange(col, row, value)`: Update cell in the Map. Set `isDirty = true`.

Save handler:
- Run client-side validation: check all cells filled, breakpoints valid
- If validation fails, set `errors` and highlight empty cells via `emptyCells` set
- If valid, serialize state to JSON and submit via `useFetcher`:
  ```typescript
  fetcher.submit(
    { intent: "save", data: JSON.stringify({ name, widthBreakpoints, heightBreakpoints, cells: [...] }) },
    { method: "post" }
  );
  ```
- On success response: set `isDirty = false`, show success Toast
- On error response: show error Banner with server validation errors

Add `<UnsavedChangesPrompt isDirty={isDirty} />` to warn on navigation.

Show loading state on Save button when `fetcher.state === "submitting"`.

If matrix has 0 breakpoints (created with "Custom" template), show a `Banner` with info tone: "Add width and height breakpoints to start building your price grid."
  </action>
  <verify>
1. Navigate to a matrix editor page (create one first via `/app/matrices/new`)
2. Grid displays with correct breakpoints and cells
3. Click a cell, type a price — value updates
4. Click "+" on width axis — new column appears
5. Click "x" on a breakpoint — column/row removed
6. Click Save with all cells filled — saves successfully, Toast confirms
7. Click Save with empty cells — validation error, empty cells highlighted
8. Make a change, click Matrices in nav — unsaved changes modal appears
9. Refresh page — saved data persists
  </verify>
  <done>Matrix editor page renders with editable spreadsheet grid. Merchants can add/remove breakpoints (capped at 50x50), edit prices inline, and save with full client+server validation. Unsaved changes prompt prevents data loss. Breakpoints auto-sort ascending.</done>
</task>

</tasks>

<verification>
1. Matrix editor loads and displays the grid correctly
2. All cell editing, breakpoint add/remove, and save operations work
3. Validation prevents saving with empty cells
4. Unsaved changes warning appears on navigation
5. TypeScript compiles: `npx tsc --noEmit`
6. Data persists correctly in database after save
</verification>

<success_criteria>
- Spreadsheet-style grid renders with breakpoints as headers on both axes
- Cells are inline-editable with number inputs
- Breakpoints can be added (+) and removed (x) from both axes
- Breakpoints auto-sort ascending
- Maximum 50x50 grid size enforced
- All cells must be filled before save (validation with highlighting)
- Save persists atomically to database
- Unsaved changes modal prevents accidental data loss
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-matrix-management/02-03-SUMMARY.md`
</output>
